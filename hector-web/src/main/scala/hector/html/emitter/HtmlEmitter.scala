package hector.html.emitter

import com.google.common.collect.ImmutableSortedSet

import hector.html._
import hector.util.{TextOutput, trimToOption}

import javax.annotation.Nullable
import javax.annotation.concurrent.ThreadSafe

import scala.xml._

/**
 * The HtmlEmitter is used to emit a string for a given Node.
 *
 * <p>The actual implementation will make sure that:
 *   <ul>
 *     <li>Text is escaped.</li>
 *     <li>Output contains only of valid characters. Invalid data is ignored.</li>
 *     <li>Consecutive whitespace is trimmed</li>
 *     <li>Invalid tag names are replaced with "invalidName".</li>
 *     <li>Invalid attribute names are replaced with "invalidName".</li>
 *     <li>Invalid prefix names are replaced with "invalidName".</li>
 *     <li>Output contains only valid entity references. Invalid data is ignored.</li>
 *     <li>Output is formatted according to given DTD.</li>
 *   </ul>
 * </p>
 *
 * <p>An invalid tag name would be <code>Elem("foo bar", ...)</code> where "foo bar" is an
 * invalid name. The same applies for attribute values and prefixes. Although when using
 * XML literals it is impossible to create such malformed data it is an extra security check
 * in order to prevent mistakes like <code>Elem(loadSomethingFromDB(), ...)</code>.</p>
 *
 * <p>The HtmlEmitter is also very strict when it comes to entity references such as &amp;amp. If
 * a given entity name is not known or not of the form &amp;#UUUU; or &amp;#xHHHH; it is ignored.</p>
 *
 * <p>Furthermore the HtmlEmitter can pretty-print any data with little impact on performance. Microbenchmark
 * scores using real-world data suggest that using <code>stripComments</code> and <code>trim</code>
 * have little to no performance impact. In fact using <code>trim</code> might increase performance
 * since less data needs to be checked for escaping.</p>
 *
 * <p>When using <code>trim</code> and <code>humanReadable</code> the HtmlEmitter will generate
 * pretty html output that is easy on the eye, ignoring any indentation in the actual Scala code.</p>
 */
@ThreadSafe
object HtmlEmitter {
  //
  // Note:
  //   Please do not try to replace the while-loops in this code with a foreach-equivalent.
  //   HtmlEmitter may contain code duplicates (in _string for instance) which are only there
  //   in order to improve performance and not have any unnecessary object allocations.
  //
  //   If you make any changes to this file you must run the HtmlEmitterBenchmark for it.
  //   To do so you can use "hector-microbenchmark/run" from within SBT.
  //
  //   Also check the generated bytecode with "javap -c -p ..." and make sure that no object
  //   allocations appear in any "_method" or "visit".
  //
  //   You might also be surprised about the fact that _string performs actual escaping and
  //   that we do not rely on

  private[this] val CharsCommentOpen = "<!--".toCharArray

  private[this] val CharsCommentClose = "-->".toCharArray

  private[this] val CharsTagClose = "</".toCharArray

  private[this] val CharsCDataOpen = "<![CDATA[".toCharArray

  private[this] val CharsCDataClose = "]]>".toCharArray

  private[this] val CharsProcInstrOpen = "<?".toCharArray

  private[this] val CharsProcInstrClose = "?>".toCharArray

  private[this] val CharsEscapedLt = "&lt;".toCharArray

  private[this] val CharsEscapedGt = "&gt;".toCharArray

  private[this] val CharsEscapedAmp = "&amp;".toCharArray

  private[this] val CharsEscapedQuot = "&quot;".toCharArray

  def toString(html: Node, docType: DocType = DocTypes.`HTML 5`, stripComments: Boolean = false, trim: Boolean = false, humanReadable: Boolean = false): String = {
    //
    // See https://developers.google.com/speed/articles/web-metrics
    //
    // I also read that the average character data is at 20k bytes but I am missing the
    // source for that information. However 20.000 lines up closely to other observed pages.
    // You can try it via "curl http://... | wc -c"
    //
    // This size should be part of a configuration with the default being 20k.
    //
    val stringBuilder = new StringBuilder(20000) //TODO(joa): make me configurable.
    val writer = new TextOutput(stringBuilder, humanReadable)

    //val typeBuffer = new scala.collection.mutable.ArrayBuffer[Int](0x200)
    //calculateWhitespace(html, typeBuffer)

    // Whitespace is collapsed to the left.
    //
    // In the following conditions the whitespace is not collapsed:
    //    <pre>-context
    //    "white-space: pre" via CSS
    //
    // There are also other tags which clear the collapse behaviour.
    // Specifically <br/>, <p> and other elements leading to a page break.
    // However this can depend entirely on CSS too.
    //
    // <b>foo</b> <i>bar</i><br/>      {foo}{ }{bar}
    // <b>foo </b> <i>bar</i><br/>     {foo }{bar}
    // <b>foo</b> <i> bar</i><br/>     {foo}{ }{bar}
    // <b>foo </b> <i> bar</i><br/>    {foo }{bar}
    //
    // Note that any whitespace immediately following an opening tag is ignored.
    // Note that any whitespace immediately preceeding a closing tag is ignored.
    //

    _dtd(docType)(writer)

    visit(html, docType, stripComments, trim)(writer)

    stringBuilder.toString()
  }

  private[this] def calculateWhitespace(node: Node, types: scala.collection.mutable.ArrayBuffer[Int]) {
    node match {
      case Text(value) ⇒
        val chars = value.toCharArray
        val n = chars.length
        var i = 0
        var isOnlyWhitespace = true

        while(i < n && isOnlyWhitespace) {
          isOnlyWhitespace = chars(i) match {
            case ' ' | '\r' | '\n' | '\t' ⇒ true
            case _ ⇒ false
          }

          i += 1
        }

        // 0 = whitespace only
        // 1 = text only
        // 2 = text, begins with whitespace
        // 3 = text, ends with whitespace
        // 4 = text, begins and ends with whitespace

        if(isOnlyWhitespace) {
          // " "
          types += 0
        } else {
          // It is safe to assume chars is not empty since otherwise isOnlyWhitespace would
          // be set to true.

          types +=
            chars(0) match {
              case ' ' | '\r' | '\n' | '\t' ⇒
                chars(n - 1) match {
                  case ' ' | '\r' | '\n' | '\t' ⇒
                    //" foo "
                    4
                  case _ ⇒
                    // " foo"
                    2
                }
              case _ ⇒
                chars(n - 1) match {
                  case ' ' | '\r' | '\n' | '\t' ⇒
                    //"foo "
                    3
                  case _ ⇒
                    //"foo"
                    1
                }
            }
        }

      case elem: Elem ⇒
        val iterator = elem.child.iterator

        while(iterator.hasNext) {
          calculateWhitespace(iterator.next(), types)
        }

      case Group(nodes) ⇒
        val iterator = nodes.iterator

        while(iterator.hasNext) {
          calculateWhitespace(iterator.next(), types)
        }

      case _ ⇒
    }
  }

  private[this] def visit(node: Node, docType: DocType, stripComments: Boolean, trim: Boolean)(implicit writer: TextOutput) {
    import scala.xml._

    // Subsequent whitespace could be removed. This should be something we have to consider since
    // it will generate an Html output that is much easier on the eye when looking at the source.

    node match {
      case Text(value) ⇒
        _string(value, trim)

      case elem: Elem ⇒
        // Note: Using a pattern match like one would expect, e.g. case Elem(prefix, label, attributes, scope, children)
        // will lead to a MatchError.

        @Nullable val prefix = elem.prefix
        val label = elem.label
        @Nullable val attributes = elem.attributes
        val scope = elem.scope
        val children = elem.child

        if(children.isEmpty) {
          _lt()
          _tag(prefix, label, attributes, scope)
          if(docType != DocTypes.`HTML 5` && docType != DocTypes.`XHTML 5`) {
            _tagCloseShort()
          } else {
            _gt()
          }
        } else {
          _lt()
          _tag(prefix, label, attributes, scope)
          _gt()

          _newLineOpt()
          writer.pushIndent()

          val iterator = children.iterator

          while(iterator.hasNext) {
            visit(iterator.next(), docType, stripComments, trim)
          }

          _tagCloseLong(prefix, label)
        }
        _newLineOpt()

      case Group(nodes) ⇒
        val iterator = nodes.iterator

        while(iterator.hasNext) {
          visit(iterator.next(), docType, stripComments, trim)
        }

      case Unparsed(data) ⇒
        writer.print(data)

      case EntityRef(name) ⇒
        _entity(name)

      case PCData(data) ⇒
        //
        // This is <![CDATA[data]]> but not PCData because PCData is Atom apparently
        //
        _cdataOpen()
        writer.print(data)
        _cdataClose()

      case ProcInstr(target, text) ⇒
        _procInstrOpen()
        writer.print(target)
        trimToOption(text) match {
          case Some(textValue) ⇒
            _space()
            writer.print(textValue)
          case None ⇒
        }
        _procInstrClose()

      case Comment(text) ⇒
        if(!stripComments) {
          _commentOpen()
          _string(text, trim)
          _commentClose()
          _newLineOpt()
        }

      case atom: Atom[_] ⇒
        //
        // Apparently someone decided to name PCDATA not PCDATA but Atom.
        // So we will have to treat it like parsed character data.
        //
        _string(atom.data.toString, trim)
    }
  }

  @inline
  private[this] def _dtd(docType: DocType)(implicit writer: TextOutput) {
    writer.print(docType.charArray)
    _newLine()
  }

  private[this] def _tag(@Nullable prefix: String, label: String, @Nullable attributes: MetaData, scope: NamespaceBinding)(implicit writer: TextOutput) {
    if(null != prefix) {
      _prefix(prefix)
      _colon()
    }

    _name(label)

    import scala.xml._

    //
    // About the weirdness: MetaData is an iterator in itself. So MetaData.next returns the next
    // element which can be null, Null or an Attribute.
    //

    var iterator = attributes

    while(null != iterator && Null != iterator) {
      //
      // Calling hasNext would lead to an error and instead we must check for Null.
      //
      // Because we tested for Null in the header the cast is safe here.
      //

      val attribute = iterator.asInstanceOf[Attribute]
      iterator = iterator.next

      @Nullable val prefix = attribute.pre
      val label = attribute.key
      @Nullable val value = attribute.value

      _space()

      if(null != prefix) {
        _prefix(prefix)
        _colon()
      }

      _name(label)

      if(null != value) {
        writer.print('=')
        writer.print('"')

        val iterator = value.iterator

        while(iterator.hasNext) {
          _attributeValue(iterator.next())
        }

        writer.print('"')
      }
    }

    //TODO(joa): how did he implement namespaces?! its quite weird ...
    //scope
  }

  private[this] def _attributeValue(node: Node)(implicit writer: TextOutput) {
    node match {
      case text: Text ⇒
        // Never trim any attributes because this is absolutely the decision of the
        // person generating an attribute in the first place.
        _string(text.data, trim = false)

      case Unparsed(data) ⇒
        writer.print(data)

      case Group(group) ⇒
        val iterator = group.iterator
        while(iterator.hasNext) {
          _attributeValue(iterator.next())
        }

      case invalid ⇒ sys.error("Invalid node "+invalid+" in attribute value.")
    }
  }

  private[this] def _tagCloseLong(@Nullable prefix: String, label: String)(implicit writer: TextOutput) {
    writer.print(CharsTagClose)

    if(null != prefix) {
      _prefix(prefix)
      _colon()
    }

    _name(label)
    writer.print('>')

    writer.popIndent()
  }

  private[this] def _tagCloseShort()(implicit writer: TextOutput) {
    writer.print('/')
    _gt()
  }

  private[this] def _entity(name: String)(implicit writer: TextOutput) {
    if(isEntity(name)) {
      _and()
      writer.print(name)
      _semi()
    }
  }

  private[this] def _prefix(prefix: String)(implicit writer: TextOutput) {
    if(isName(prefix)) {
      writer.print(prefix)
    } else {
      writer.print("invalidName")
    }
  }

  private[this] def _name(name: String)(implicit writer: TextOutput) {
    if(isName(name)) {
      writer.print(name)
    } else {
      writer.print("invalidName")
    }
  }

  private[this] def _cdataOpen()(implicit writer: TextOutput) {
    writer.print(CharsCDataOpen)
  }

  private[this] def _cdataClose()(implicit writer: TextOutput) {
    writer.print(CharsCDataClose)
    writer.newLineOpt()
  }

  private[this] def _procInstrOpen()(implicit writer: TextOutput) {
    writer.print(CharsProcInstrOpen)
  }

  private[this] def _procInstrClose()(implicit writer: TextOutput) {
    writer.print(CharsProcInstrClose)
    writer.newLineOpt()
  }

  private[this] def _colon()(implicit writer: TextOutput) {
    writer.print(':')
  }

  private[this] def _lt()(implicit writer: TextOutput) {
    writer.print('<')
  }

  private[this] def _gt()(implicit writer: TextOutput) {
    writer.print('>')
  }

  private[this] def _commentOpen()(implicit writer: TextOutput) {
    writer.print(CharsCommentOpen)
    _spaceOpt()
  }

  private[this] def _commentClose()(implicit writer: TextOutput) {
    _spaceOpt()
    writer.print(CharsCommentClose)
  }

  private[this] def _newLine()(implicit writer: TextOutput) {
    writer.newLine()
  }

  private[this] def _newLineOpt()(implicit writer: TextOutput) {
    writer.newLineOpt()
  }

  private[this] def _space()(implicit writer: TextOutput) {
    writer.print(' ')
  }

  private[this] def _spaceOpt()(implicit writer: TextOutput) {
    writer.printOpt(' ')
  }

  private[this] def _string(value: String, trim: Boolean)(implicit writer: TextOutput) {
    import writer.print

    val chars = (if(trim) trimHtmlText(value) else value).toCharArray
    val n = chars.length
    var i = 0

    var indexStart = -1

    //
    // The escape method is a little bit special but easy to understand.
    //
    // 1) Print-Characters Only (' ' <= x <= '~'):
    //
    //    Example: ['f', 'o', 'o'].
    //
    //    In the first iteration when looking at 'f' we match a print character and set indexStart
    //    to 0 because it was -1. Now for the following characters 'o' and 'o' nothing happens.
    //
    //    After the loop the range [indexStart, n) will be printed from the sequence of
    //    characters if indexStart is not -1. This will create only one call to
    //    writer.print().
    //
    // 2) Trivial Escape Characters (\n, \r\, \t):
    //
    //    Example: ['f', 'o', 'o', '\n', 'b', 'a', 'r']
    //
    //    In the first iteration when looking at 'f' we set indexStart to 0. Once we encounter
    //    the escape character '\n' we perform no special action since it is valid and has
    //    no escaped HTML entity. We continue processing like in case (1).
    //    Only one call to writer.print() will be made.
    //
    // 3) Non-Trivial Escape Characters (<, >, &, "):
    //
    //    Example: ['f', 'o', 'o', '&', 'b', 'a', 'r']
    //
    //    In the first iteration when looking at 'f' we set indexStart to 0. When we reach the
    //    '&' character the following happens:
    //
    //      - Print all character data in the range [indexStart, i) if indexStart != -1
    //      - Set i to -1 so that the next trivial character will mark it
    //      - Print the HTML entity &amp; instead of &.
    //
    //    This will lead to less calls to writer.print. In fact each escape character requires
    //    an additional 2 calls so we have (1 + 2 * numEntities) calls to writer.print in the worst
    //    case.
    //

    while(i < n) {
      val char = chars(i)

      char match {
        case '<' ⇒
          if(-1 != indexStart) {
            print(chars, indexStart, i - indexStart)
            indexStart = -1
          }

          print(CharsEscapedLt)

        case '>' ⇒
          if(-1 != indexStart) {
            print(chars, indexStart, i - indexStart)
            indexStart = -1
          }

          print(CharsEscapedGt)

        case '&' ⇒
          if(-1 != indexStart) {
            print(chars, indexStart, i - indexStart)
            indexStart = -1
          }

          print(CharsEscapedAmp)

        case '"' ⇒
          if(-1 != indexStart) {
            print(chars, indexStart, i - indexStart)
            indexStart = -1
          }

          print(CharsEscapedQuot)

        case '\n' | '\r' | '\t' ⇒
          if(-1 == indexStart) {
            indexStart = i
          }

        case printChar if ' ' <= printChar && printChar <= '~' ⇒
          if(-1 == indexStart) {
            indexStart = i
          }

        case _ ⇒
          //TODO(joa): notify developer?
      }

      i += 1
    }

    if(-1 != indexStart) {
      print(chars, indexStart, n - indexStart)
    }
  }

  private[this] def _and()(implicit writer: TextOutput) {
    writer.print('&')
  }

  private[this] def _semi()(implicit writer: TextOutput) {
    writer.print(';')
  }

  /**
   * trimHtmlText tries to trim an arbitrary Html text node.
   *
   * <p>Note that it is not possible to simply trim any content because "&lt;span&gt;foo &lt;/span&gt;bar"
   * would look like "foobar" if we simply trim any text node. Therefore we have two options:</p>
   * <ul>
   *   <li>Trim the text keeping the first and/or last whitespace character</li>
   *   <li>Trim the text, keep only the necessary first and/or last whitespace character</li>
   * </ul>
   *
   * <p>Since it is not trivial to determine whether or not a whitespace character is required we
   * will go with the first option for now.</p>
   *
   * @param value The text to trim.
   *
   * @return The trimmed value; may still start or end with a whitespace character.
   */
  private[this] def trimHtmlText(value: String): String =
    if(null != value) {
      val length = value.length

      if(length == 1) {
        // Make no attempt to trim a single character because it could be \n, \x32 or anything
        // else and we do want to preserve single whitespace.
        value
      } else {
        val firstChar = value.charAt(0)
        val lastChar = value.charAt(length - 1)

        value match {
          case startsAndEndsWithWhitespace if Character.isWhitespace(firstChar) && Character.isWhitespace(lastChar) ⇒
            firstChar+startsAndEndsWithWhitespace.trim+lastChar

          case startsWithWhitespace if Character.isWhitespace(firstChar) ⇒
            firstChar+startsWithWhitespace.trim

          case endsWithWhitespace if Character.isWhitespace(lastChar) ⇒
            endsWithWhitespace.trim+lastChar

          case ordinaryString ⇒
            ordinaryString
        }
      }
    } else if(null == value) {
      // Catch any null values and return "" instead.
      ""
    }  else {
      // Empty string.
      value
    }

  // The isName method is not used correct since prefix:label makes a name and Elem
  // does not define it as such. For now we do it like isName(prefix):isName(label)
  // so in fact the "label" part of Elem is also checked for isNameStart but in the end
  // it is only making sure that a name is correct even tough label is null.

  private[this] def isName(value: String): Boolean =
    if(null == value || value.length < 1) {
       false
     } else {
       val charArray = value.toCharArray

       if(isNameStart(charArray(0))) {
         val n = value.length
         var i = 1
         var valid = true

         while(valid && i < n) {
           valid = isNamePart(charArray(i))
           i += 1
         }

         valid
       } else {
         false
       }
     }

  /**
   * http://www.w3.org/TR/2000/REC-xml-20001006#NT-Name
   * @param char
   * @return
   */
  private[this] def isNameStart(char: Char): Boolean =
    char match {
      case letter if Character.isLetter(letter) ⇒ true
      case '_' | ':' ⇒ true
      case _ ⇒ false
    }

  /**
   * http://www.w3.org/TR/2000/REC-xml-20001006#NT-Name
   *
   * @param char
   * @return
   */
  private[this] def isNamePart(char: Char): Boolean =
    char match {
      case letter if Character.isLetter(letter) ⇒ true
      case digit if Character.isDigit(digit) ⇒ true
      case '.' | '-' | '_' | ':' ⇒ true
      //case Extender ⇒ true
      //case Combiner ⇒ true
    }

  private[this] val ValidUnicodeEntityRegex = """^#\d{1,4}$""".r

  private[this] val ValidHashEntityRegex = """^#x[abcdefABCDEF0-9]{1,4}$""".r

  private[this] val ValidEntities =
    ImmutableSortedSet.of[String](
      "quot",  "amp", "apos", "lt", "gt", "nbsp",
      "iexcl", "cent", "pound", "curren", "yen", "brvbar",
      "sect", "uml", "copy", "ordf", "laquo", "not", "shy", "reg",
      "macr", "deg", "plusmn", "sup2", "sup3", "acute", "micro", "para",
      "middot", "cedil", "sup1", "ordm", "raquo", "frac14", "frac12", "frac34",
      "iquest", "Agrave", "Aacute", "Acirc", "Atilde", "Auml", "Aring", "AElig",
      "Ccedil", "Egrave", "Eacute", "Ecirc", "Euml", "Igrave", "Iacute", "Icirc",
      "Iuml", "ETH", "Ntilde", "Ograve", "Oacute", "Ocirc", "Otilde", "Ouml",
      "times", "Oslash", "Ugrave", "Uacute", "Ucirc", "Uuml", "Yacute", "THORN",
      "szlig", "agrave", "aacute", "acirc", "atilde", "auml", "aring", "aelig",
      "ccedil", "egrave", "eacute", "ecirc", "euml", "igrave", "iacute", "icirc",
      "iuml", "eth", "ntilde", "ograve", "oacute", "ocirc", "otilde", "ouml", "divide",
      "oslash", "ugrave", "uacute", "ucirc", "uuml", "yacute", "thorn", "yuml", "OElig",
      "oelig", "Scaron", "scaron", "Yuml", "fnof", "circ", "tilde", "Alpha", "Beta", "Gamma",
      "Delta", "Epsilon", "Zeta", "Eta", "Theta", "Iota", "Kappa", "Lambda", "Mu", "Nu",
      "Xi", "Omicron", "Pi", "Rho", "Sigma", "Tau", "Upsilon", "Phi", "Chi", "Psi", "Omega",
      "alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota",
      "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigmaf", "sigma",
      "tau", "upsilon", "phi", "chi", "psi", "omega", "thetasym", "upsih", "piv", "ensp",
      "emsp", "thinsp", "zwnj", "zwj", "lrm", "rlm", "ndash", "mdash", "lsquo", "rsquo",
      "sbquo", "ldquo", "rdquo", "bdquo", "dagger", "Dagger", "bull", "hellip", "permil", "prime",
      "Prime", "lsaquo", "rsaquo", "oline", "frasl", "euro", "image", "weierp", "real", "trade",
      "alefsym", "larr", "uarr", "rarr", "darr", "harr", "crarr", "lArr", "uArr", "rArr", "dArr",
      "hArr", "forall", "part", "exist", "empty", "nabla", "isin", "notin", "ni", "prod", "sum",
      "minus", "lowast", "radic", "prop", "infin", "ang", "and", "or", "cap", "cup", "int",
      "there4", "sim", "cong", "asymp", "ne", "equiv", "le", "ge", "sub", "sup", "nsub", "sube",
      "supe", "oplus", "otimes", "perp", "sdot", "lceil", "rceil", "lfloor", "rfloor", "lang",
      "rang", "loz", "spades", "clubs", "hearts", "diams")

  private[this] def isEntity(name: String): Boolean = {
    val firstChar = name.charAt(0)

    firstChar match {
      case '#' ⇒
        // &#DDDD; and &#xDDDD;
        // Note that name is only "#DDDD" or "#xDDDD"

        if(name.length > 6) {
          false
        } else {
          ValidUnicodeEntityRegex.pattern.matcher(name).matches() ||
          ValidHashEntityRegex.pattern.matcher(name).matches()
        }

      case _ ⇒ ValidEntities contains name
    }
  }
}
